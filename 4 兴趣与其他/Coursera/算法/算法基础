



为什么要学习算法？

普通、简单的方法可能会消耗大量时间和空间



## 0 算法基础：

直接将问题的解法转换为程序的解法会很慢，所以可以通过一些算法解决这些问题

### 0.1 斐波那契数列

![image-20210305110610315](image-20210305110610315.png)

最初使用来解决兔子的生育的问题，问题是如何计算斐波那契数列

#### 0.1.1第一种算法

```python
if n<1:
	return n
else:
	retuen fib(n-1)+fib(n-2)
```

计算该算法的执行复杂度$T(n)$：

![image-20210305142125598](image-20210305142125598.png)

![image-20210305142107794](image-20210305142107794.png)
$$
T(n)=\begin{cases} 2， n\le1\\ T(n-1)+T(n-2)+3 ,else\end{cases} 
$$
该算法的执行效率之所以低是因为在递归的过程中进行了很多重复计算

![image-20210305143026076](image-20210305143026076.png)

#### 0.1.2第二种算法

在手算的过程中，需要将所有数字写出来进行相加，依照这种思想使用数列将所有斐波那契数存储：

![image-20210305143844789](image-20210305143844789.png)

### 0.2 最大公约数

计算两个数的最大公约数

![image-20210305145405500](image-20210305145405500.png)

![image-20210305144834558](image-20210305144834558.png)

#### 0.1.1 第一种方法

![image-20210305145137427](image-20210305145137427.png)



从1开始计算能够被两个数整除的数字，如果都能整除就设为最佳值，一直循环到两个数的和

#### 0.1.2 d

定理1：a’为a除以b后的余数，则b与a的最大公约数等于b与a’的最大公约数

![image-20210305150351956](image-20210305150351956.png)

利用余数的性质写成算法：

![image-20210305151006022](image-20210305151006022.png)

![image-20210305151619488](image-20210305151619488.png)

![image-20210305151609608](image-20210305151609608.png)

### 0.2 大O表示

程序具体的执行时间受到很多因素的影响，程序的编译、硬件的性能等，但是这些因素造成的影响都是常数级别的，我们在描述一个算法的执行时间的时候考虑它随输入尺度变换(渐近线asymptotic)的程度，而不关心其具体执行时间。

![image-20210305155204269](image-20210305155204269.png)



上图代表输入n的长度，max n是运行一秒的时候输入的最大长度

![image-20210306103741290](image-20210306103741290.png)



对不不同数量级的大小有
$$
da
$$

**大O表示：当存在常数 $N$ 和 $c$ ，使得对所有的 $n\geq N$ 都有 $f(n) \leq cg(n)$ 的时候，也就是 $f(n)$ 的上界被$cg(n)$ 所限制的时候，可以表示为** $f(n)=O(g(n))$ 

- 使用大O表示可以描述程序不同算法之间效率的尺度关系，但这种表示方式忽略了常数，所以不能对常数倍数的时间差异进行描述。

![image-20210306144917634](image-20210306144917634.png)

以计算斐波那契数列的算法为例子：

![image-20210306152644889](image-20210306152644889.png)

其他的表示方法，

<img src="image-20210306152723855.png" alt="image-20210306152723855" style="zoom:80%;" />

小o表述定义：

![image-20210306152745817](image-20210306152745817.png)

大O表述和小o表述的不同在于$f\prec g$的时候为有 $f=o(g)$ ，当 $f\preceq g$有$f=O(g)$

这种表述方式描述的是 $f$ 的增长速度小于 $g$ ，所以表述 $5n^2=O(n^3)$ 和表述 $5n^2=O(n^2)$ 都是正确的















