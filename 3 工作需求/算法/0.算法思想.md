# 算法思想

本文主要对常用的算法思想进行总结：

- [ ] 双指针
- [x] 动态规划
- [ ] 贪心策略
- [x] 递归
- [ ] 分治



## 1.递归

递归的思想主要是将大的问题拆解为在已知子问题结果下的问题，通过一次次拆解最终得到容易解决的小问题，对小问题求解得到结果后进行回溯就实现解决大问题的目的。

![截屏 2021-04-08 上午11.27.17](%E6%88%AA%E5%B1%8F%202021-04-08%20%E4%B8%8A%E5%8D%8811.27.17.jpeg)

### 1.1递归模板

在使用递归的过程一定要注意两点，一个是调用自己，一个是终止条件，终止条件一定要写在前面，然后才是对自己的调用，想下面这样：

```python
def recursion(params):
  if 终止条件：
      return
  recursion(params)
```

终止条件的部分一定要在前面否则就会陷入重复递归的过程，出现堆栈溢出异常(StackOverflowError)

### 1.2递归的例子

在使用递归的时候假设n-1时候的结果已经得到，只需要考虑如何根据当前参数以及n-1时候的结果求出来最终的结果即可。

####1.2.1 阶乘

运用递归实现阶乘的思想是在求n的阶乘的时候假设已经知道了n-1时候的阶乘为factorial(n-1)，这个时候求n的阶乘只需要$n\times factorial(n-1)$即可，递归的终止条件是n=1的时候，此时阶乘结果为1。

```python
#1.用递归的思想实现阶乘
    def factorial(self,n):
        if n == 1:
            return 1
        return n * self.factorial(n-1)
```

当n=5的时候调用过程如下:

![图片](640.png)

#### 1.2.2 斐波那契数列

斐波那契数列的形式是$[1,1,2,3,5,8,13,...]$其中当n=1和n=2的时候值为1，其他时候为前两个元素的和，使用递归实现求解n的时候的斐波那契数列：

```python
#2.斐波那契数列
def fibonacci(self,n):
    if n==1 or n==2:
        return 1
    return self.fibonacci(n-1)+self.fibonacci(n-2)
```

#### 1.2.3 哈诺塔问题

哈诺塔问题指的是有三个柱子A,B,C，其中A上面堆满了盘子，盘子从上到下尺寸依次增大，要求将A中的盘子全都移动到C上去，并且在移动过程中需要保证小尺寸的盘子在上。首先需要考虑终止条件，显然当A柱子上的盘子个数为1的时候，我们只需要将其借助B柱子移动到C上就可以结束了，下面考虑在n的时候如何处理，我们在前面的递归问题中说过，假设n-1这个子问题已经被解决，那么我们就可以调用函数实现n-1个盘子的移动，首先需要借助C将其移动到B（hanoi(n-1,A,C,B)）,然后将A柱上的一个盘子移动到C，最后借助A柱将B上的n-1个盘子移动到C（hanoi(n-1,B,A,C)）。

```python
#3.哈诺塔
    def hanoi(self,n,A,B,C):
        if n ==1 :
            print("从"+A+"移动到"+C)
        else:
            self.hanoi(n-1,A,C,B)
            print("从"+A+"移动到"+C)
            self.hanoi(n-1,B,A,C)
```



参考文章[什么是递归，通过这篇文章，让你彻底搞懂递归](https://mp.weixin.qq.com/s?__biz=MzU0ODMyNDk0Mw==&mid=2247487910&idx=1&sn=2670aec7139c6b98e83ff66114ac1cf7&chksm=fb418286cc360b90741ed54fecd62fd45571b2caba3e41473a7ea0934f918d4b31537689c664&token=910002910&lang=zh_CN#rd)

## 2.动态规划

动态规划的思想中一般包含了递归过程，要想理解动态规划的概念首先需要要了解重复递归现象。

- 重复递归运算：在进行递归求解的过程中我们可能会重复计算同一个递归值，例如在递归求解斐波那契数列的时候，其递归求解的代码如下：

```python
def fibonacci(self,n):
    if n==1 or n==2:
        return 1
    return self.fibonacci(n-1)+self.fibonacci(n-2)
```

当我们需要计算 $f(5)$ 的时候需要对 $f(4)$ 和 $f(3)$ 进行递归计算，在计算$f(4)$的时候又需要计算$f(3)$和$f(2)$，这里$f(3)$就被计算了两遍，出现了重复计算。

![img](1-2.png)

- 记忆化递归：我们希望能够简化计算过程，即对每一个递归值只计算一次，然后将计算后的结果存储起来，下一次只需要从之前存储的值中取出来使用即可，这种方式称为记忆化递归法。
- 动态规划：记忆化递归的过程实际就很好诠释了动态规划的核心思想，即每一次计算的时候都利用之前已经计算好的数据而不需要进行重复运算。说到这里想到马尔科夫链，这种结构每一个状态的值都只和前一个状态有关而与再之前的状态都无关，这种结构就可以使用动态规划的思想来解决，每一次存储前一个状态的值而下一次直接对存储值进行取出应用即可。



### 2.1动态规划的思想过程

动态规划在本质上含有递归的过程，所以在求解这类题目的时候首先可以考虑递归过程，然后在递归过程中发现重复运算部分，使用记忆化递归对原求解进行优化。

### 2.2 动态规划题目

#### 2.2.1 爬楼梯

![image-20210423112334229](image-20210423112334229.png)

第一眼看到这个题思路就是递归，在求解n阶台阶问题的时候首先第一步肯定是爬一个或者两个台阶，然后只需要考虑n-1阶问题和n-2阶问题就行，即$f(n)=f(n-1)+f(n-2)$，同时考虑递归结束条件，当n为0的时候为0，n为1的时候只有一种方法为1，n为2的时候有两种方法为2，也就是当$n<3$的时候问题的解就是n，接下来就可以写代码了：

```python
#递归求解
def climbStairs(self, n: int):
    if n < 3:
        return n
    return self.climbStairs(n-1)+self.climbStairs(n-2)
```

递归的方式很容易理解，但是这种解法存在我们上面提到的重复递归运算，我们可以通过对递归结果的存储避免重复运算的发生，具体的方法是建立一个列表用来对之前计算的结果进行存储。

```python
#优化后递归 具有记忆功能的递归
#对递归结果进行存储避免重复运算
def climbStairs(self , n):
    a_list = n*[0]
    def help(n):
        if n<=2:
            return n
        if a_list[n-2]!=0 and a_list[n-3]!=0:
            return a_list[n-2]+a_list[n-3]
    for i in range(n):
        a_list[i] = help(i+1)
    return a_list[n-1]
```

在上面的运算过程中我们可以看到在求解第n步的时候只用到了第n-1和n-2的信息，所以再之前的信息实际上是没有用的，进一步简化，我们只要两个变量对前两次的结果进行存储即可：

```python
#再找到递归公式后进行简化，只用两个变量存储之前两个状态即可
def climbStairs(self, n):
    q = 0
    r = 1
    for i in range(n):
        p = q
        q = r
        r = p+q
    return r
```

q和p两个变量分别存储前两个状态，通过前两个状态对当前状态r进行计算。

> 如果对斐波那契数列熟悉的话通过上面的递推公式就可以看出这个爬台阶的问题其实就是菲波那切数列，由于斐波那契数列存在公式
>
> ![image.png](ae684255d88d2094c9555b308b5fdb5fffb6a7876d9305c4020cf5a2579f4470-image.png)
>
> 所以可以直接用公式来计算：
>
> ```python
> import math
> sqrt_5 = math.sqrt(5)
> return int(1/sqrt_5*(((1+sqrt_5)/2)**(n+1)-((1-sqrt_5)/2)**(n+1)))
> ```
>
> 这个题遵循的数列是1,2,3,5...相比于斐波那契数列少一项，所以上面的递推公式中为n+1。



####2.2.2 买卖股票的最佳时机

![image-20210425103626795](image-20210425103626795.png)

显然看到这个题最简单的思路就是暴力求解，两个循环算出来所有利润的值然后从其中选出来最大的就好，外循环从数组起始开始，内循环从外循环的起始+1开始，遍历的时间复杂度$O(n^2)$。第二种想法只需要遍历一遍即可，从头开始记录当前遇到的最小值，然后拿当前值与最小值做差比较这个值与最大利润的大小。

- 方法1：暴力求解

暴力求解的方法计算所有可能的利润值然后找出来最大的，这种方法需要使用两个循环，外循环遍历所有所有元素，内循环遍历从外循环当前元素开始遍历到最后，计算两个循环遍历元素的差值作为利润值，如果比最大值要大就进行存储。

```python
#方法1：暴力求解（超时）
def maxProfit(self,prices):
    max = 0
    for i in range(len(prices)):
        for j in range(i+1,len(prices)):
            temp = prices[j] - prices[i]
            if temp > max:
                max = temp
    return max
```

时间复杂度：$O(n^2)$

空间复杂度：$O(1)$

- 方法2：双指针，动态规划

初始化两个变量`min`和`max`分别用来存储当前遍历到的元素最小值以及当前情况下的最大利润，从头开始遍历记录当前遍历到的最小值，然后拿当前值与其作差将这个差值与最大利润作比较，如果大于就更新最大利润。

```python
#方法2：双指针，动态规划
def maxProfit(self,prices):
    min = float('inf')
    max = 0
    for i in range(len(prices)):
        if prices[i]<min:
            min = prices[i]
        if prices[i]-min>max:
            max = prices[i]-min
```

时间复杂度：$O(n)$

空间复杂度：$O(1)$

- 方法3：递归

之前我们说过动态规划的题目中一般会含有一个递归过程，同样的这个题也可以用递归的思想解决，使用递归的过程同样需要记录两个值：当前遇到最小值与目前的最大利润。使用递归需要两个基本要素：1.递归的终止条件是当数组中只有一个值的时候此时最小值为该值而最大利润为0，2.递归调用是每次都调用当前数组长度-1的数组`help(prices_list[:n-1])`。

```python
#方法3：递归求解（超时）
def maxProfit(self,prices):
    def help(prices_list):
        if len(prices_list)==1:
            min_p = prices_list[0]
            profit = 0
            return min_p,profit
        n = len(prices_list)
        min_p,profit = help(prices_list[:n-1])
        if prices_list[n-1]<min_p:
            min_p = prices_list[n-1]
        if prices_list[n-1]-min_p>profit:
            profit = prices_list[n-1]-min_p
        return min_p,profit
    min_p,profit = help(prices)
    return profit
```

**时间复杂度**：$O(n)$

**空间复杂度**：$O(n)$

#### 2.2.3 最大子序和

![image-20210425145656942](image-20210425145656942.png)

这个题我自己想了半天也没想出来怎么求解，只好去看了答案，官方答案给出两种比较容易理解的解法，一是贪心策略，二是动态规划的思想，下面分别介绍：

- 方法1：贪心策略

我们从数组的起始开始遍历，每加入一个新的元素时候就计算累加值并与当前最大值进行比较决定是否更新，在这个过程中如果遍历元素之前的累加值小于0的时候我们就丢弃它如果大于0就继续累加。

```python
#方法2：贪心算法
def maxSubArray(self,nums):
    if len(nums)==1:
        return nums[0]
    max_sum = nums[0]
    cur_sum = nums[0]
    for i in range(1,len(nums)):
        if cur_sum<0:
            cur_sum = nums[i]
        else:
            cur_sum = cur_sum+nums[i]
        if cur_sum>max_sum:
            max_sum=cur_sum
    return max_sum
```

我们以下面的数组为例分别求出当前和与最大和的数值，当前和小于0的时候我们就舍弃之并将当前值设为当前和，因为小于0的数总是会越加越小。

![image-20210425151812005](image-20210425151812005.png)



- 方法2：动态规划

我们可以将原来的问题分解为求解以标号为i元素结尾的最大子序列和，其中i从0到n-1取值，这样我们就可以从开始进行遍历，每一次求出以元素i为结尾的子序列的最大值即这个解为$f(i)$，那么$f(i+1)=max(f(i)+num[i+1],nums[i+1])$，实际就是说当$f(i)<0$的时候我们就另起炉灶以当前值作为最大值。

```python
#@方法1：动态规划
def maxSubArray(self, nums):
    if len(nums)==1:
        return nums[0]
    for i in range(1,len(nums)):
        if nums[i-1]>0:
            nums[i]=nums[i]+nums[i-1]
    return max(nums)
```

上面的代码对原来的数组进行修改，使得数组中的每一个值都表示以当前元素为结尾的子序列的最大值，所以只需要对这个数组求最大值就能得到最终解。

![image-20210425155022487](image-20210425155022487.png)



















