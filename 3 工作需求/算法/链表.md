# 链表

链表这种数据结构中的每一个元素都有两个属性，分别是指向下一个节点的指针和当前节点的值（双向链表还有指向前一个节点的指针）。

![img](screen-shot-2018-04-12-at-152754.png)

与数组这一数据结构不同，链表不能通过索引直接访问，而只能从头开始找到需要访问的节点，所以其访问时间是 $O(N)$，而数组可以通过索引直接访问所以其访问时间是 $O(1)$；但是对于链表来说其插入和删除操作非常方便，在已经知道前一节点的情况下插入与删除操作的时间复杂度为 $O(1)$，相比之下，数组在执行插入和删除操作后后面所有元素的索引值都需要改变，所以时间复杂度为 $O(N)$

下面是插入操作的示意：

![插入操作](screen-shot-2018-04-25-at-163243.png)

下面是删除操作的示意图：

![删除操作](screen-shot-2018-04-26-at-203640.png)

## 0 设计一个链表

### 0-1 设计一个单向链表

![image-20210406094733124](image-20210406094733124.png)

```python
class ListNode:
    def __init__(self,x):
        self.val = x
        self.next = None

class MyLinkedList:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.size = 0
        self.head = ListNode(0)


    def get(self, index: int) -> int:
        """
        Get the value of the index-th node in the linked list. If the index is invalid, return -1.
        """
        if index<0 or index>=self.size:
            return -1
        cur = self.head
        for _ in range(index+1):
            cur = cur.next
        return cur.val

    def addAtIndex(self, index: int, val: int) -> None:
        """
        Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.
        """
        if index < 0:
            index = 0
        if index > self.size:
            return
        pred = self.head
        for _ in range(index):
            pred = pred.next
        to_add = ListNode(val)
        to_add.next = pred.next
        pred.next = to_add
        self.size += 1

    def addAtHead(self, val: int) -> None:
        """
        Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.
        """
        self.addAtIndex(0,val)

    def addAtTail(self, val: int) -> None:
        """
        Append a node of value val to the last element of the linked list.
        """
        self.addAtIndex(self.size,val)

    def deleteAtIndex(self, index: int) -> None:
        """
        Delete the index-th node in the linked list, if the index is valid.
        """
        if index<0 or index>=self.size:
            return
        if index==self.size-1:
            pred_to_del = self.head
            for _ in range(index):
                pred_to_del = pred_to_del.next
            pred_to_del.next = None
        else:
            to_del = self.head
            for _ in range(index+1):
                to_del = to_del.next
            to_del.val = to_del.next.val
            to_del.next = to_del.next.next
        self.size -= 1
```

上面的设计中删除操作有一些麻烦，删除操作也可以这样写：

```python
    def deleteAtIndex(self,index):
        if index < 0 or index >= self.size:
            return
        pred = self.head
        for _ in range(index):
            pred = pred.next
        pred.next = pred.next.next
        self.size -= 1
```











