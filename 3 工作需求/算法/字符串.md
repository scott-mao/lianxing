# 字符串



## 1.反转字符串

![image-20210327101113176](image-20210327101113176.png)

反转字符串的操作其实就相当于沿着中心对字符串进行对折，所以只要首尾两边元素交换就行，代码也很简单：

```python
def reverseString(self,string):
    n = len(string)
    for i in range(n//2):
        string[i],string[n-i-1] = string[n-i-1],string[i]
```

## 2.整数反转

![image-20210327101321739](image-20210327101321739.png)



看到这个题的直接想法就是首先将整数转换为数组进行翻转然后再将其转换回来：

- 方法1：整数->list->整数

```python
def reverse_int(self,x):
    sign = 1
    y=0
    if x<0:
        sign =-1
        x=-x
    a = x
    list_x = []
    while a != 0:
        num = a % 10
        list_x.append(num)
        a = int(a/10)
    # self.reverseString(list_x)
    for i in range(len(list_x)):
        y = y+list_x[i] *10**(len( list_x)-i-1)
    y = sign*y
    if y <-2**31 or y >2 **31-1:
        return 0
    return y
```

- 方法2：第二种想法就是直接对整数进行操作，利用取余以及除法操作取每一位数，然后将相应位的数字进行转换：

```python
def reverse_int(self ,x):
    num =0  # 记录位数 y=0  #  记  数
    sign = 1
    # 记录符号
    if x<0:
        sign = -1
        x = -x
    # 获取位数
    x_1 = x
    while True:
        if int(x_1/10)!=0:
            num = num+1
            x_1 = int(x_1/10)
        else:
            num = num+1
            break
    # 得到反转后数
    for i in range(num,0,-1):
        y = y+(x%10)* ( 10 * *(i - 1))
        x = int(x/10)
    y = sign*y
    if y <-2**31 or y > 2**31-1:
        return 0
    return y
```

在我自己的解答中涉及要计算位数，这个过程其实完全没有必要，下面是简化版的代码：

```python
def reverse_int(self ,x):
    y=abs(x)
    num = 0
    boundry = (1<<31)-1 if x>0 else 1<<31
    while y !=0:
        num = y%10 +num*10
        if num>boundry:
            return 0
        y = y//10
    return num if x>0 else -num
```



## 3.字符串中的第一个唯一字符

![image-20210328221217928](image-20210328221217928.png)

第一次看到这题想到想先把字符串转换为数字然后统计数组中第一个不重复元素，但转念一想这样没啥好处啊，不如直接将字符串转换为数组。直接对数组从前到后进行遍历的话时间复杂度有点高$O(n^2)$，看到底下有个哈希表的标签，emm，用哈希表存储每一个元素出现的次数！然后返回第一个次数是1的元素对应其在数组中的序号就好，废话少说，直接上代码：

```python
		def firstUniqChar(self,s):
        s_list = list(s)
        hashtable = dict()
        for i in s_list:
            if i in hashtable:
                hashtable[i] = hashtable[i] + 1
                continue
            hashtable[i] = 1

        for i in range(len(s_list)):
            if hashtable[s_list[i]] == 1:
                return i
        return -1
```

一共遍历两次，时间复杂度$O(n)$，比上面的方法好得多。

## 4.有效的字母异位词

![image-20210329094834904](image-20210329094834904.png)

第一次看还理解错了题意，我还以为是指相同位置有不一样的字母就是字母异位词。实际题意是单词中的字母种类和次数都相同就是次序不同则是字母异位词。

看到这个题底下的标签了，所以两种解法呼之欲出。

- 方法一：排序，先将字符串转换为列表，然后对列表排序，对比两个列表是否相等即可。

```python
#方法一：排序后判断是否相等
    def isAnagram(self,s,t):
        s_list = list(s)
        t_list = list(t)
        s_list.sort()
        t_list.sort()
        if s_list == t_list:
            return True
        return False
```

- 方法二：哈希表，哈希表存储第一个字符串每个字母出现的次数，然后再进行遍历第二个字符串，如果不存在相应字母或者字母次数不一致就False。

```python
#方法二：利用哈希表判断字符次数
    def isAnagram(self,s,t):
        hashtable = dict()
        if len(s) != len(t):
            return False
        for i in range(len(s)):
            if s[i] in hashtable:
                hashtable[s[i]] += 1
                continue
            hashtable[s[i]] = 1
        for j in range(len(t)):
            if (t[j] not in hashtable) or (hashtable[t[j]]==0):
                return False
            hashtable[t[j]] -= 1
        return True
```

- 方法三：利用set集合存储所有不同的字母，然后对字母进行遍历，如果字母出现次数相同则True，反之False。

```python
#方法三：利用set集合
    def isAnagram(self,s,t):
        if len(s) != len(t):
            return False
        for i in set(s):
            if s.count(i) != t.count(i):
                return False
        return True
```

## 5.验证回文串

![image-20210330103325014](image-20210330103325014.png)

回文这个字一出现就想到双指针的思想，头尾两个指针比较，相等就向中间移动知道左面指针大于或等于右面指针结束，因为这个题目中还含有其他字符，所以判断当当前指针不是字母数字的时候就移动即可。另外还想到一种思想就是在开辟一个字符串存储之前字符串中所有的数字和字母，然后与其倒序的字符串进行比较即可。

- 方法1：双指针，头尾指针，相等则像中间移动，不等返回False

```python
#方法1：双指针，开始一个，最后一个，比较字母和数字是否相同，不同则False，若相同当左面指针等于或者大于右面的时候结束
    def isPalindrome(self,s):
        if len(s) <= 1:
            return True
        n = len(s)
        first = 0
        last = n-1
        while True:
            while not s[first].isalnum() and first<n-1:
                first = first + 1
            while not s[last].isalnum() and last>0:
                last = last - 1
            if (not s[first].isalnum()) and (not s[last].isalnum()):
                return True
            if s[first].lower() == s[last].lower():
                first = first + 1
                last = last - 1
                if first >= last:
                    break
                continue
            return False
        return True
    #简化版双指针，思想一样就是简化了一些行
    def isPalindrome(self, s: str) -> bool:
        n = len(s)
        left, right = 0, n-1
        while left < right:
            while left < right and not s[left].isalnum():
                left += 1
            while left < right and not s[right].isalnum():
                right -= 1
            if s[left].lower() != s[right].lower():
                return False
            left += 1
            right -= 1
        return True

```

- 方法2：使用另一数组存储字母数组然后与其倒序进行比较。

```python
#方法2：将字符串中所有字符和数字存在另一个变量temp中，判断temp和其倒序字符串temp[::-1]是否相同
def isPalindrome(self,s):
    temp=''
    for i in range(len(s)):
        if s[i].isalnum():
            temp = temp+s[i]
    if temp == temp[::-1]:
        return True
    return False
```

- 方法3：正则表达式，从网友那学的，将所有的非字母数字替换掉然后与其自身倒序进行比较。

```python
#方法3：使用正则表达式将所有非数字和字母全都替换掉，换成小写后与其倒序字符串比较
import re
def isPalindrome(self,s):
    temp = re.sub("[^a-zA-Z0-9]","",s) 
    temp = temp.lower()
    return temp == temp[::-1]
```









