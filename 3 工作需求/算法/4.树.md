# 树

树是一种基本的数据结构，树里的每一个节点包含当前节点的值和所有子节点的列表。本节主要介绍最基本的树状结构——二叉树，在二叉树的定义中，每一个节点仅有左右两个子树。下图就是一种典型的二叉树结构。

![Unknown](Unknown.png)

## 0 二叉树构建

二叉树中每一个节点包含当前节点的值和指向的左右两个子树，默认情况下指向的是`None`节点

```python
class TreeNode:
    def __init__(self,val=0,left=None,right=None):
        self.val = val
        self.left = left
        self.right = right
tree1_node2 = TreeNode(3)
tree1_node1 = TreeNode(2)
tree1_root1 = TreeNode(1,left=tree_node2,right=tree1_node1)
```

这样就构建了一个最基本的树结构：

![image-20210412153141575](image-20210412153141575.png)

## 1 二叉树的遍历

二叉树的遍历主要分为前序、中序、后序和层序遍历，不同的遍历方式得到的数值顺序也会有所不同。

### 1.1 前序遍历

假设我们具有如下图所示的二叉树结构，二叉树的前序遍历规则是根节点-遍历左子树-遍历右子树。

![image-20210412154624213](image-20210412154624213.png)

前序遍历的过程很好理解，下面我们来具体实现前序遍历的，前序遍历的实现这里主要介绍三种方法：递归法、栈以及Morris方法。

- 方法1：递归法

使用递归可以很方便实现对于树结构的遍历，应用递归的时候我们需要考虑两点：结束条件和递归调用，在初始节点为根节点的情况下，我们只需要考虑输出根节点的值，其左右子树都可以通过递归函数输出，在不断进行的递归的过程中终止条件就是最终会到达叶子节点，这个时候其左右子节点都为`None`只需要返回空值即可。

```python
def preorderTraversal(self,root):
    if root == None:
        return []
    return [root.val]+self.preorderTraversal(root.left)+self.preorderTraversal(root.right)
```

- 方法2：栈

前序遍历这种方式首先输出的是左面节点的值，所以我们可以首先遍历左面节点并对左面的节点进行存储，存储的过程就是进栈，当左面节点遍历结束后就依次出栈遍历这些节点的右面节点即可。

```python
#方法2：栈
def preorderTraversal(self,root):
    node = root
    stack = list()
    result =list()
    if not root:
        return []
    while stack or node:
        while node:
            result.append(node.val)
            stack.append(node)
            node = node.left
        node = stack.pop()
        node = node.right
    return result
```

[官方题解](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/er-cha-shu-de-qian-xu-bian-li-by-leetcode-solution/)这里有PPT可以参考着看很直观

- 方法3：Morris 遍历

Morris遍历使用二叉树节点中大量指向空的指针，其时间复杂度为 $O(n)$，但是空间复杂度相比与上面两种算法要少得多为 $O(1)$。使用Morris遍历的通用过程如下：

![image-20210412163540645](image-20210412163540645.png)

其整体思路是从根节点开始。每一次都找到其左子树对应的最右侧节点与这个根节点连接，在建立完整个连接之后就能根据这个连接对所有节点进行遍历。下面是使用morris遍历的具体过程：

![image-20210412173139663](image-20210412173139663.png)

具体的代码流程：

```python
#方法3：Morris 遍历
def preorderTraversal(self,root):
    if root == None:
        return []
    list = []
    cur1 = root
    cur2 = None

    while cur1:
        cur2 = cur1.left
        if cur2:
            while (cur2.right != None) and (cur2.right != cur1):
                cur2 = cur2.right
            if cur2.right == None:
                cur2.right = cur1
                list.append(cur1.val)
                cur1 = cur1.left
                continue
            elif cur2.right == cur1:
                cur2.right = None
        else:
            list.append(cur1.val)
        cur1 = cur1.right
    return list
```

### 1.2 二叉树的中序遍历

 中序遍历的过程是首先遍历左子树，然后是根节点最后是右子树。

![image-20210413102318023](image-20210413102318023.png)

有了前面前序遍历的基础，中序遍历的程序也就很好写了，同样是有三种方法，具体的原理就不再赘述，直接看三种方法的代码：

- 方法1：递归

递归的方法非常简单，在之前的程序基础上只需要做一点变动即可

```python
#方法1：递归
def inorderTraversal(self, root):
    if root == None:
        return []
    return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)
```

复杂度分析：

1. 时间复杂度：$O(n)$，二叉树中每一个节点都被访问一次
2. 空间复杂度：$O(n)$，空间复杂度取决于栈的深度，当二叉树为一条链的时候会达到$O(n)$时间复杂度

- 方法2：栈

栈的思想非常简单，其实就是将递归过程中的隐式栈显式的表现出来，首先对所有的左节点都进行压栈操作，然后出栈的时候输出节点值并处理当前节点的右子树。

```python
#方法2：栈
def inorderTraversal(self,root):
    if root == None:
        return []
    node = root
    stack = list()
    tree_list = list()

    while node or stack:
        cur = node
        while cur:
            stack.append(cur)
            cur = cur.left
        out = stack.pop()
        tree_list.append(out.val)
        node = out.right
    return tree_list
```

复杂度分析：

1. 时间复杂度：$O(n)$，二叉树中每一个节点都被访问一次
2. 空间复杂度：$O(n)$，空间复杂度取决于栈的深度，当二叉树为一条链的时候会达到$O(n)$时间复杂度

- 方法3：Morris遍历

具体的遍历方式看前序遍历中的讲解，简单的说就是对利用二叉树中的一些空节点进行了利用从而保证能够对所有节点进行遍历。

```python
#方法3：Morris遍历
def inorderTraversal(self,root):
    if root == None:
        return []
    cur1 = root
    tree_list = list()


    while cur1:
        cur2 = cur1.left
        if cur2 != None:

            #移动到左子树的最后侧节点并建立连接
            while cur2.right and cur2.right != cur1:
                    cur2 = cur2.right
            if cur2.right == None:#没有连接的话建立连接
                cur2.right = cur1
                cur1 = cur1.left
            elif cur2.right == cur1: #如果已有连接就删除
                tree_list.append(cur1.val)
                cur1 = cur1.right
                cur2.right = None

        else:
            tree_list.append(cur1.val)
            cur1 = cur1.right
    return tree_list
```

[力扣官方给的解答](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/)中有PPT很直观，可以一看

复杂度分析：

1. 时间复杂度：$O(n)$，二叉树中每一个节点都被访问两次，总的时间复杂度为$O(2n)=O(n)$
2. 空间复杂度：$O(1)$，没有使用额外的空间

















