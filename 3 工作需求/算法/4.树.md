# 树

树是一种基本的数据结构，树里的每一个节点包含当前节点的值和所有子节点的列表。本节主要介绍最基本的树状结构——二叉树，在二叉树的定义中，每一个节点仅有左右两个子树。下图就是一种典型的二叉树结构。

![Unknown](Unknown.png)

## 0 二叉树构建

二叉树中每一个节点包含当前节点的值和指向的左右两个子树，默认情况下指向的是`None`节点

```python
class TreeNode:
    def __init__(self,val=0,left=None,right=None):
        self.val = val
        self.left = left
        self.right = right
tree1_node2 = TreeNode(3)
tree1_node1 = TreeNode(2)
tree1_root1 = TreeNode(1,left=tree_node2,right=tree1_node1)
```

这样就构建了一个最基本的树结构：

![image-20210412153141575](image-20210412153141575.png)

## 1 二叉树的遍历

二叉树的遍历主要分为前序、中序、后序和层序遍历，不同的遍历方式得到的数值顺序也会有所不同。前中后的区分方式是根据遍历根节点的顺序，前序遍历就是根节点首先遍历，中序遍历就是根节点在中间遍历，而后序遍历就是最后遍历根节点。

### 1.1 前序遍历

假设我们具有如下图所示的二叉树结构，二叉树的前序遍历规则是根节点-遍历左子树-遍历右子树。

![image-20210412154624213](image-20210412154624213.png)

前序遍历的过程很好理解，下面我们来具体实现前序遍历的，前序遍历的实现这里主要介绍三种方法：递归法、栈以及Morris方法。

- 方法1：递归法

使用递归可以很方便实现对于树结构的遍历，应用递归的时候我们需要考虑两点：结束条件和递归调用，在初始节点为根节点的情况下，我们只需要考虑输出根节点的值，其左右子树都可以通过递归函数输出，在不断进行的递归的过程中终止条件就是最终会到达叶子节点，这个时候其左右子节点都为`None`只需要返回空值即可。

```python
def preorderTraversal(self,root):
    if root == None:
        return []
    return [root.val]+self.preorderTraversal(root.left)+self.preorderTraversal(root.right)
```

- 方法2：栈

前序遍历这种方式首先输出的是左面节点的值，所以我们可以首先遍历左面节点并对左面的节点进行存储，存储的过程就是进栈，当左面节点遍历结束后就依次出栈遍历这些节点的右面节点即可。

```python
#方法2：栈
def preorderTraversal(self,root):
    node = root
    stack = list()
    result =list()
    if not root:
        return []
    while stack or node:
        while node:
            result.append(node.val)
            stack.append(node)
            node = node.left
        node = stack.pop()
        node = node.right
    return result
```

[官方题解](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/er-cha-shu-de-qian-xu-bian-li-by-leetcode-solution/)这里有PPT可以参考着看很直观

- 方法3：Morris 遍历

Morris遍历使用二叉树节点中大量指向空的指针，其时间复杂度为 $O(n)$，但是空间复杂度相比与上面两种算法要少得多为 $O(1)$。使用Morris遍历的通用过程如下：

![image-20210412163540645](image-20210412163540645.png)

其整体思路是从根节点开始。每一次都找到其左子树对应的最右侧节点与这个根节点连接，在建立完整个连接之后就能根据这个连接对所有节点进行遍历。下面是使用morris遍历的具体过程：

![image-20210412173139663](image-20210412173139663.png)

具体的代码流程：

```python
#方法3：Morris 遍历
def preorderTraversal(self,root):
    if root == None:
        return []
    list = []
    cur1 = root
    cur2 = None

    while cur1:
        cur2 = cur1.left
        if cur2:
            while (cur2.right != None) and (cur2.right != cur1):
                cur2 = cur2.right
            if cur2.right == None:
                cur2.right = cur1
                list.append(cur1.val)
                cur1 = cur1.left
                continue
            elif cur2.right == cur1:
                cur2.right = None
        else:
            list.append(cur1.val)
        cur1 = cur1.right
    return list
```

### 1.2 中序遍历

 中序遍历的过程是首先遍历左子树，然后是根节点最后是右子树。

![image-20210413102318023](image-20210413102318023.png)

有了前面前序遍历的基础，中序遍历的程序也就很好写了，同样是有三种方法，具体的原理就不再赘述，直接看三种方法的代码：

- 方法1：递归

递归的方法非常简单，在之前的程序基础上只需要做一点变动即可

```python
#方法1：递归
def inorderTraversal(self, root):
    if root == None:
        return []
    return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)
```

复杂度分析：

1. 时间复杂度：$O(n)$，二叉树中每一个节点都被访问一次
2. 空间复杂度：$O(n)$，空间复杂度取决于栈的深度，当二叉树为一条链的时候会达到$O(n)$时间复杂度

- 方法2：栈

栈的思想非常简单，其实就是将递归过程中的隐式栈显式的表现出来，首先对所有的左节点都进行压栈操作，然后出栈的时候输出节点值并处理当前节点的右子树。

```python
#方法2：栈
def inorderTraversal(self,root):
    if root == None:
        return []
    node = root
    stack = list()
    tree_list = list()

    while node or stack:
        cur = node
        while cur:
            stack.append(cur)
            cur = cur.left
        out = stack.pop()
        tree_list.append(out.val)
        node = out.right
    return tree_list
```

复杂度分析：

1. 时间复杂度：$O(n)$，二叉树中每一个节点都被访问一次
2. 空间复杂度：$O(n)$，空间复杂度取决于栈的深度，当二叉树为一条链的时候会达到$O(n)$时间复杂度

- 方法3：Morris遍历

具体的遍历方式看前序遍历中的讲解，简单的说就是对利用二叉树中的一些空节点进行了利用从而保证能够对所有节点进行遍历。

```python
#方法3：Morris遍历
def inorderTraversal(self,root):
    if root == None:
        return []
    cur1 = root
    tree_list = list()


    while cur1:
        cur2 = cur1.left
        if cur2 != None:

            #移动到左子树的最后侧节点并建立连接
            while cur2.right and cur2.right != cur1:
                    cur2 = cur2.right
            if cur2.right == None:#没有连接的话建立连接
                cur2.right = cur1
                cur1 = cur1.left
            elif cur2.right == cur1: #如果已有连接就删除
                tree_list.append(cur1.val)
                cur1 = cur1.right
                cur2.right = None

        else:
            tree_list.append(cur1.val)
            cur1 = cur1.right
    return tree_list
```

[力扣官方给的解答](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/)中有PPT很直观，可以一看

复杂度分析：

1. 时间复杂度：$O(n)$，二叉树中每一个节点都被访问两次，总的时间复杂度为$O(2n)=O(n)$
2. 空间复杂度：$O(1)$，没有使用额外的空间

### 1.3 后序遍历

二叉树的后序遍历先遍历左子树，然后是右子树，最后是根节点。跟上面两种遍历方式类似，后序遍历同样可以通过三种方式解决，只不过由于遍历顺序的不同需要对其中输出节点的顺序进行改变。

![image-20210414163739752](image-20210414163739752.png)

- 方法1：递归

递归的方法非常简单，也很容易理解

```python
#方法1：递归
def postorderTraversal(self,root):
    if root == None:
        return []
    return   self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val]
```

- 方法2：栈

对当前根节点左面的节点进行入栈操作，然后出栈的时候将出栈的节点的右子树作为根节点同样进行入栈操作，如此重复就能实现对整个树的遍历，在这个过程中最重要的是如何判断什么时候输出值，

```python
#方法2：栈
def postorderTravelsal(self,root):
    if root == None:
        return []
    stack = list()
    result = list()

    node = root
    prec = None
    while node or stack:
        while node != None:
            stack.append(node)
            node = node.left
        node = stack.pop()
        #当右侧没有节点或者当前节点已经被遍历过时输出值
        if (not node.right) or (node.right == prec):
            result.append(node.val)
            prec = node
            node = None
        else:
            stack.append(node)
            node = node.right
    return result
```

- 方法3：Morris遍历

和上面两种遍历方式类似，Morris遍历的方式就是通过利用空的右节点建立连接实现对整个树的遍历过程，但与之前两种方式不同的时候，在后序遍历中输出值的顺序和这种遍历方式的顺序并不是完全符合，所以需要考虑在遍历过程中如何输出值的问题，在下面的题解中在去除连接的时候输出值.

```python
def postorderTravelsal(self, root):

    def save_list( node,result):
        temp_list = list()
        while node:
            temp_list.append(node.val)
            node = node.right
        temp_list.reverse()
        result = result + temp_list
        return result
    if root == None:
        return []
    cur1 = root
    result = list()

    while cur1:
        cur2 = cur1.left
        if cur2:
            while cur2.right and cur2.right != cur1: 
                cur2 = cur2.right
            if cur2.right == None:
                cur2.right = cur1
                cur1 = cur1.left
                continue
            else: #去除连接并输出值
                cur2.right = None 
                result = save_list(cur1.left,result)
        cur1 = cur1.right
    result = save_list(root,result)
    return result
```

上面的写法每次都要建立一个新的列表，可以直接对添加的数据进行倒序操作：

```python
def postorderTravelsal(self, root):

    def addPath(node):
        count = 0
        while node:
            result.append(node.val)
            node = node.right
            count = count + 1
        i = len(result)-count
        j = len(result)-1
        while i<j:
            result[i],result[j] = result[j],result[i]
            i += 1
            j -= 1

    if root == None:
        return []
    cur1 = root
    result = list()

    while cur1:
        cur2 = cur1.left
        if cur2:
            while cur2.right and cur2.right != cur1:
                cur2 = cur2.right
            if cur2.right == None:
                cur2.right = cur1
                cur1 = cur1.left
                continue
            else:
                cur2.right = None
                addPath(cur1.left)
        cur1 = cur1.right
    addPath(root)
    return result
```

### 1.4 层序遍历

二叉树的层序遍历顾名思义就是按照层来进行遍历，每一次都按照从左到右的顺序对每一层的元素进行输出，下面是一个二叉树层序遍历的输出示意：

![image-20210415122104278](image-20210415122104278.png)

![image-20210415140013415](image-20210415140013415.png)

- 方法1：队列实现

二叉树的层序遍历可以通过队列的方式实现，实现的思路是每一次都对每一层的节点进行入队存储，然后出队的时候输出改层节点的值并用另一个队列存储下一层的所有节点，如此重复知道队列为空。

```python
def levelOrder(self, root: TreeNode):
    if root == None:
        return []
    queue = collections.deque()
    temp_queue = collections.deque()
    queue.append(root)
    result = []
    temp_res = []
    while queue:
        node = queue.popleft()
        temp_res.append(node.val)
        if node.left:
            temp_queue.append(node.left)
        if node.right:
            temp_queue.append(node.right)
        if not queue:
            result = result + [temp_res]
            queue = temp_queue
            temp_res = []
            temp_queue = collections.deque()
    return result
```

- 方法2：递归实现

由于我们要返回的是一个包含列表的列表，每一个列表的位置实际就代表着元素所在层数，所以我们需要在使用递归添加元素的时候对层数进行指明。在下面的递归函数中就明确指出当前需要添加到列表中的位置，在根节点的时候添加到第一个列表，然后其子节点就相应的添加到第二个列表，如果当前列表数比层数少的时候就添加新的列表。

```python
def levelOrder(self, root: TreeNode):
    result = [[]]
    def add_elements(root,level):
        if root and len(result) == level-1: #当前列表层数<遍历到树的层数 添加新的列表
            result.append([])
        if len(result) >= level: #当前列表层数>=遍历到数的层数 在相应层添加元素
            result[level-1].append(root.val)
        if root.left: #如果当前节点存在左子树，对左子树进行层序遍历
            add_elements(root.left,level+1)
        if root.right:#如果当前节点存在右子树，对右子树进行层序遍历
            add_elements(root.right,level+1)
        return result

    if root == None:
        return []
    return add_elements(root,1)
```

有时间的时候总结一下模板：https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/tao-mo-ban-bfs-he-dfs-du-ke-yi-jie-jue-by-fuxuemin/

## 2.二叉树的最大深度

![image-20210416151228454](image-20210416151228454.png)



其实上面层序遍历的过程后就可以直接输出二叉树的最大深度，如果只求深度的话反而更简单。这个题主要想到两种思路，第一种是递归，第二种就是广度优先搜索。

- 方法1：递归

再次不厌其烦的回顾使用递归的模板：终止条件+递归调用。求深度的时候终止条件就是遇到None节点时候此时返回的深度应该是0，其他情况下返回其左节点和右节点的最大深度+1。

```python
def maxDepth(self, root: TreeNode):
    if root == None:
        return 0
    return max(self.maxDepth(root.left)+1,self.maxDepth(root.right)+1)
```

模仿之前层序遍历的过程有这种嵌套函数的递归写法：

```python
def maxDepth(self, root: TreeNode) :
    cur_depth = 0
    max_depth = 0
    def count_cur_depth(root, cur_depth):
        nonlocal max_depth
        if cur_depth > max_depth:
            max_depth = cur_depth
        if root.left:
            count_cur_depth(root.left,cur_depth+1)
        if root.right:
            count_cur_depth(root.right,cur_depth+1)
        return max_depth
    if root == None:
        return cur_depth
    return count_cur_depth(root,1)
```



- 方法2：广度优先搜索

可以对依次每一行进行遍历，当该行所有节点不存在子节点的时候就返回深度的值，因为只需要记录深度这一个值所以使用栈队列的数据结构都可以。

```python
#方法2：栈
def maxDepth(self, root: TreeNode):
    if root == None:
        return 0
    stack = list()
    temp_stack = list()
    stack.append(root)
    depth = 0
    while stack or temp_stack:
        node = stack.pop()
        if node.left:
            temp_stack.append(node.left)
        if node.right:
            temp_stack.append(node.right)
        if not stack:
            depth = depth + 1
            stack = temp_stack
            temp_stack = list()
    return depth
```















