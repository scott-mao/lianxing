# 数组



## [1 删除排序数组中的重复项](https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2gy9m/)

![image-20210318114925199](image-20210318114925199.png)

懒得抄题了，直接粘上来

我的解法：

```python
def function(nums):
    if len(nums) == 1:
        return 1
    for i in range(len(nums)):
        for j in range(i+1,len(nums)):
            if (j == len(nums) - 1) and (nums[i] == nums[j]):
                n = i
                return n+1
            if nums[j] == nums[i]:
                continue

            elif nums[j] > nums[i]:
                nums[i+1] = nums[j]
                break
```

主要思想是设置两个索引，一个`i`从数组开始遍历，一个`j=i+1`处开始遍历，当有`nums[j]>num[i]`的时候就把后面的值赋到前面来，如此反复就能使得前面存在一个不重复的数组，这个数组的结束条件是 `(j == len(nums) - 1) and (nums[i] == nums[j])`.。提交上去提示超时间，淦！

网友解法：

```python
def removeDuplicates(nums) :
    for i in range(len(nums) - 1, 0, -1):
        if nums[i] == nums[i - 1]:
            del nums[i]
    return len(nums)
```

直接逆序索引，从后往前看，后一个与前一个相等就删除后一个，这也太简单了趴，我这个菜鸡搞了半小时还超时，惭愧...

## [2 买卖股票的最佳时机 II](https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2zsx1/)

懒得抄题好吧：

![image-20210318114942656](image-20210318114942656.png)

我的解法：

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        sum = 0
        for i in range(len(prices)-1):
            if prices[i] < prices[i+1]:
                money=prices[i+1] - prices[i]
                sum = sum+money
            else:
                continue
        return sum
```

使用贪心策略，每一次都考虑当前天和第二天，如果第二天股票大于第一天那就记录这个差值到`sum`，然后移动当前指针将第二天作为当前天重复这个策略记录，直到第二天的股票小于等于第一天就停止记录。一直记录到最后一天就返回`sum`的值就是卖股票的最佳收益。

## 3 旋转数组

懒得抄题选手再得一分！

![image-20210318114854819](image-20210318114854819.png)

方法一：这题一开始想的是一个一个的移动，从第一个开始找到他所需要移动到的位置进行替换，然后将该位置的数暂存在一个变量，在依次找到下一个位置的数，这样重复找的次数就是数组的长度，在有些情况下上运行良好，但是当数组长度为偶数的且移动位置k也是偶数的时候就会出现卡在一个位置的情况，进一步思考，当数组的长度只要是移动位置k的倍数的时候就会发生原地打转的情况，解决的方法是每次进行移动操作后都对移动后位置的索引进行记录，当下一次发现当前位置的索引被记录的时候就对当前位置加1，这样就避免了每次都重复在一个地方。

下面是代码：

```python
def rotate( nums, k):
    """
    Do not return anything, modify nums in-place instead.
    """
    index = 0
    temp_1 = nums[index]
    l_nums = len(nums)
    index_visted = []
    for i in range(l_nums):
        next_id = (index + k) % l_nums
        if next_id in index_visted: %如果下一个位置已经被访问过
            index = index + 1
            temp_1 = nums[index]
            next_id = (index + k) % l_nums
        temp_2 = nums[next_id]
        nums[next_id] = temp_1
        temp_1 = temp_2
        index = next_id
        index_visted.append(index)
```

正好代码讲解里面有这个思想的讲解，废话不多说，直接偷图：


![1610074370-FCoknu-image](1610074370-FCoknu-image.png)

![1610074389-JbBnZF-image](1610074389-JbBnZF-image.png)

如果`nums.length%k=0`，也就是数组长度为k的倍数，这个会原地打转，如下图所示

![1610074663-JRcbFv-image](1610074663-JRcbFv-image.png)

方法二：

建立一个临时数组，在这个数组内装已经向后移动过的数组：

偷图选手再次出现：

![1610068849-iinvCs-image](1610068849-iinvCs-image.png)



```python
def rotate(nums,k):
    list_nums  = nums.copy()
    for i in range(len(nums)):
        list_nums[(i+k)%len(nums)] = nums[i]
    nums[:] = list_nums[:]
```

方法三：

对原来的数组进行逆序翻转，然后只需要对前k%len(nums)个元素以及后面的元素进行翻转即可：

![1610072480-yiAYFw-image](1610072480-yiAYFw-image.png)

没错，又是偷的图。这种思想非常的amazing啊！

```python
def reverse(nums, start, end):
    for i in range((end - start + 1) // 2):
        nums[i + start], nums[end - i] = nums[end - i], nums[i + start]
    return nums


def rotate(nums, k):
    """
        Do not return anything, modify nums in-place instead.
        """
    reverse(nums, 0, len(nums)-1)
    reverse(nums, 0, k % len(nums)-1)
    reverse(nums, k % len(nums) , len(nums)-1)

```



## 4 存在重复元素

https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x248f5/

![image-20210319150722661](image-20210319150722661.png)

偷懒第一名，题目描述如上，爱看不看。

这题比较简单，思路也比较容易想，就是首先将数组排序，然后一个个检查就行：

```python
def containsDuplicate(nums):
    nums.sort()
    for i in range(len(nums)-1):
        if nums[i] == nums[i+1]:
            return True
    return False
```

在下面的题解中看到另一种方法就是使用set函数，set函数能够创建一个无序不重复的元素集，如果对list使用set函数就会返回一个不重复的数组，那么只要统计这个数组元素个数与原来数组个数进行比较即可：

```python
def containsDuplicate(nums):
		return len(nums)!=len(set(nums))
```



## 5 只出现一次的数字

![image-20210320092038845](image-20210320092038845.png)

- 解法1：这个题要是用正常思维很容易想到直接从前往后进行遍历，首先对数组进行排序，然后对于第一个和最后一个数，只要看看和他们相邻的数是否一样，对于中间的数就看他和两边的数是否一样就行：

```python
def singleNumber(self,nums):
    nums.sort()
    if nums[0] != nums[1]:
        return nums[0]
    if nums[len(nums)-1] != nums[len(nums) - 2]:
        return nums[len(nums)-1]
    for i in range(1,len(nums)-1):
        if (nums[i]!=nums[i-1]) and (nums[i]!=nums[i+1]):
            return nums[i]
```

- 解法2：使用位运算异或可以很巧妙找到那个出现一次的数字，对于位运算异或有下面的运算法则:
  $$
  \begin{align}
  1\oplus  1=0 \\
  1\oplus 0=1 \\
  0\oplus1=1\\
  0\oplus 0 =0
  
  \end{align}
  $$
  当我们有任意的数 $a、b、c$  的时候，也就是异或满足交换律：
  $$
  \begin{align}
  0\oplus a&=a\\
  a\oplus a&=0\\
  a\oplus b\oplus c&=a \oplus c\oplus b 
  
  \end{align}
  $$
  通过上面的性质有下面的算法：

```python
def singleNumber(self,nums):
	result = 0
	for i in range(len(nums)):
		result = result^nums[i]
	return result
```





